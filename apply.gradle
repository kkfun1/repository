import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

ext {
    android = [
            versionCode      : 1,
            versionName      : "1.0.0",
            versionNameSuffix: ".0",  //这个点不能去掉
            applicationId    : "com.troy.repository",
            compileSdkVersion: 25,
            buildToolsVersion: "25.0.0",
            minSdkVersion    : 14,
            targetSdkVersion : 25,
            keystorePassword : "kkfun1",
            keystoreAlias    : "repository"
    ]

    third = [
            EASEMOB_APP_DEBUG_VALUE   : "jihuiduo#jhd-test",
            EASEMOB_APP_RELEASE_VALUE : "jihuiduo#jhd",
            JPUSH_DEBUG_APPKEY_VALUE  : "00d0768c909832030b76cba3",
            JPUSH_RELEASE_APPKEY_VALUE: "d52dbcc1eccdf976d89f51ab",
    ]

    channel = [
            DEFAULT     : "beta",
            CHANNEL_LIST: "qh360,myapp,baidu,jy91,anzhuo,wdj,mi,oppo,vivo,huawei,meizu,gionee,lenovo,anzhi,pp,sogou"
    ]

    version = [
            supportVersion         : "24.2.1",
            butterknifeVersion     : "8.2.1",
            baseAdapterVersion     : "2.3.3",
            glideVersion           : "3.7.0",
            roundedimageviewVersion: "2.2.1",
            eventbusVersion        : "3.0.0",
            analyticsVersion       : "6.0.4",
            greendaoVersion        : "3.2.0",
            greendaoHelpVersion    : "1.3.0",
            flycoTabLayoutVersion  : "2.1.0",
            okhttpVersion          : "3.4.1",
            gsonVersion            : "2.7",
            okhttp3ForGLideVersion : "1.4.0",
            stethoVersion          : "1.1.0"
    ]

    url = [
            releaseBaseURL: "https://api.jihuiduo.com",
            debugBaseURL  : "https://beta.api.jihuiduo.com"
    ]

    dependency = [
            supportDesignLib      : "com.android.support:design:${version.supportVersion}",
            supportRecyclerViewLib: "com.android.support:recyclerview-v7:${version.supportVersion}",
            supportAppCompatLib   : "com.android.support:appcompat-v7:${version.supportVersion}",
            butterknifeLib        : "com.jakewharton:butterknife:${version.butterknifeVersion}",   //注解框架
            butterknifeAptLib     : "com.jakewharton:butterknife-compiler:${version.butterknifeVersion}",
            baseAdapterLib        : "com.github.CymChad:BaseRecyclerViewAdapterHelper:${version.baseAdapterVersion}",///** 简化Adapter的书写,并且可以添加Header Footer EmptyView LoadMore Selection MultiType url!(www.recyclerview.org)[官网地址]...   */
            glideLib              : "com.github.bumptech.glide:glide:${version.glideVersion}", /// 图片加载框架
            roundedimageviewLib   : "com.makeramen:roundedimageview:${version.roundedimageviewVersion}", /// 圆角图片框架
            eventbusLib           : "org.greenrobot:eventbus:${version.eventbusVersion}", /// 事件处理
            analyticsLib          : "com.umeng.analytics:analytics:${version.analyticsVersion}", /// 统计库
            flycoTabLayoutLib     : "com.flyco.tablayout:FlycoTabLayout_Lib:${version.flycoTabLayoutVersion}@aar",// https://github.com/H07000223/FlycoTabLayout
            greendaoLib           : "org.greenrobot:greendao:${version.greendaoVersion}",// http://greenrobot.org/greendao
            greendaoHelpLib       : "com.github.yuweiguocn:GreenDaoUpgradeHelper:v${version.greendaoHelpVersion}",//GreenDao数据库升级方案 https://github.com/yuweiguocn/GreenDaoUpgradeHelper
            okhttpLib             : "com.squareup.okhttp3:okhttp:${version.okhttpVersion}",//网络请求
            gsonLib               : "com.google.code.gson:gson:${version.gsonVersion}",//gsonVersion
            okhttp3ForGLideLib    : "com.github.bumptech.glide:okhttp3-integration:${version.okhttp3ForGLideVersion}@aar",//gsonVersion
            stethoLib             : "com.facebook.stetho:stetho:${version.stethoVersion}",
            stethoHttpLib         : "com.facebook.stetho:stetho-okhttp:${version.stethoVersion}"
    ]

    formatFinalResult = this.&formatFinalResult
}

def formatFinalResult(versionName, versionNameSuffixDef, applicationVariants) {
    File pathFile = new File("./build/output/apk");
    if (!pathFile.exists()) pathFile.mkdirs();
    applicationVariants.all { variant ->
        variant.outputs.each { output ->
            def outputFile = output.outputFile
            if (outputFile != null && outputFile.name.endsWith('.apk')) {
                def fileName = null;
                def path = null;
                if (outputFile.name.contains("release")) {
                    fileName = "repository_release_v${versionName}_${variant.productFlavors[0].name}.apk"
                    File file = new File(outputFile.parent, "release/${versionName}");
                    if (!file.exists()) file.mkdirs();
                    path = file.path
                } else if (outputFile.name.contains("debug")) {
                    fileName = "repository_debug_v${versionName + versionNameSuffixDef}_${variant.productFlavors[0].name}.apk"
                    File file = new File(outputFile.parent, "debug");
                    if (!file.exists()) file.mkdirs();
                    path = file.path
                } else if (outputFile.name.contains("push")) {
                    fileName = "repository_push_v${versionName + versionNameSuffixDef}_${variant.productFlavors[0].name}.apk"
                    File file = new File(outputFile.parent, "push");
                    if (!file.exists()) file.mkdirs();
                    path = file.path
                }
                output.outputFile = new File(path, fileName)
            }
        }
    }
//    fileToZip("E:\\Work\\JHD\\Code\\app\\build\\outputs\\apk\\release\\$versionName", "E:\\Work\\JHD\\release\\$versionName", versionName)
//    copyFolder("E:\\Work\\JHD\\Code\\app\\build\\outputs\\mapping\\", "E:\\Work\\JHD\\release\\$versionName\\mapping\\")
}

public static boolean fileToZip(String sourceFilePath, String zipFilePath, String fileName) {
    boolean flag = false;
    File sourceFile = new File(sourceFilePath);
    FileInputStream fis = null;
    BufferedInputStream bis = null;
    FileOutputStream fos = null;
    ZipOutputStream zos = null;

    if (!sourceFile.exists()) {
        System.out.println("待压缩的文件目录：" + sourceFilePath + "不存在. ${sourceFile.getAbsoluteFile()}");
    } else {
        try {
            File zipFileParentFile = new File(zipFilePath);
            if (!zipFileParentFile.exists()) zipFileParentFile.mkdirs();
            File zipFile = new File(zipFilePath + "/" + fileName + ".zip");
            if (zipFile.exists()) {
                System.out.println(zipFilePath + "目录下存在名字为:" + fileName + ".zip" + "打包文件.");
            } else {
                File[] sourceFiles = sourceFile.listFiles();
                if (null == sourceFiles || sourceFiles.length < 1) {
                    System.out.println("待压缩的文件目录：" + sourceFilePath + "里面不存在文件，无需压缩.");
                } else {
                    fos = new FileOutputStream(zipFile);
                    zos = new ZipOutputStream(new BufferedOutputStream(fos));
                    byte[] bufs = new byte[1024 * 10];
                    for (int i = 0; i < sourceFiles.length; i++) {
                        //创建ZIP实体，并添加进压缩包
                        ZipEntry zipEntry = new ZipEntry(sourceFiles[i].getName());
                        zos.putNextEntry(zipEntry);
                        //读取待压缩的文件并写进压缩包里
                        fis = new FileInputStream(sourceFiles[i]);
                        bis = new BufferedInputStream(fis, 1024 * 10);
                        int read = 0;
                        while ((read = bis.read(bufs, 0, 1024 * 10)) != -1) {
                            zos.write(bufs, 0, read);
                        }
                    }
                    flag = true;
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } catch (IOException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        } finally {
            //关闭流
            try {
                if (null != bis) bis.close();
                if (null != zos) zos.close();
            } catch (IOException e) {
                e.printStackTrace();
                throw new RuntimeException(e);
            }
        }
    }
    return flag;
}

public void copyFolder(String oldPath, String newPath) {
    try {

        File newPathFile = new File(newPath);
        if (newPathFile.exists() && newPathFile.listFiles().size() > 0) return;
        (new File(newPath)).mkdirs(); //如果文件夹不存在 则建立新文件夹
        File a = new File(oldPath);
        String[] file = a.list();
        File temp = null;
        for (int i = 0; i < file.length; i++) {
            if (oldPath.endsWith(File.separator)) {
                temp = new File(oldPath + file[i]);
            } else {
                temp = new File(oldPath + File.separator + file[i]);
            }

            if (temp.isFile()) {
                FileInputStream input = new FileInputStream(temp);
                FileOutputStream output = new FileOutputStream(newPath + "/" +
                        (temp.getName()).toString());
                byte[] b = new byte[1024 * 5];
                int len;
                while ((len = input.read(b)) != -1) {
                    output.write(b, 0, len);
                }
                output.flush();
                output.close();
                input.close();
            }
            if (temp.isDirectory()) {//如果是子文件夹
                copyFolder(oldPath + "/" + file[i], newPath + "/" + file[i]);
            }
        }
    }
    catch (Exception e) {
        System.out.println("复制整个文件夹内容操作出错");
        e.printStackTrace();

    }
}

